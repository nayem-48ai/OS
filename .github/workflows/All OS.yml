name: SSH + Tailscale (Multi-OS)

on:
  workflow_dispatch:
    inputs:
      os_choice:
        description: "Choose the Operating System (ubuntu/windows/macos)"
        required: true
        type: choice
        default: 'ubuntu-latest'
        options:
          - ubuntu-latest
          - windows-latest
          - macos-latest
      ts_tailnet:         { description: "Tailscale tailnet (e.g. you@gmail.com)", required: true }
      ts_api_key:         { description: "Tailscale API key (device admin, no Bearer)", required: true }
      ts_authkey:         { description: "Tailscale Auth key (reusable or ephemeral)", required: true }
      ssh_user:           { description: "Username for SSH connection", required: true, default: "user" }
      ssh_password:       { description: "Password for the SSH user", required: true }
      quick_test:         { description: "Run 5-minute test", type: boolean, default: false }
      runtime_minutes:    { description: "Runtime (max 360; default 355 when not test)", required: false, default: "355" }
      do_purge:           { description: "Purge bullet* devices at start (single instance only)", required: false, default: "true" }
      cycles:             { description: "0=stop after this run; N=handoffs left incl this run", required: false, default: "0" }
      instance_count:     { description: "How many SSH instances (1-10)", required: false, default: "1" }

permissions:
  contents: read
  actions: write

defaults:
  run:
    shell: bash

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.mk.outputs.matrix }}
      multi:  ${{ steps.mk.outputs.multi }}
    steps:
      - id: mk
        run: |
          n=${{ inputs.instance_count }}
          if (( n < 1 )); then n=1; fi
          if (( n > 10 )); then n=10; fi

          matrix="{\"include\":["
          for i in $(seq 1 $n); do
            matrix+="{\"id\":$i}"
            if (( i < n )); then matrix+=","; fi
          done
          matrix+="]}"
          echo "matrix=$matrix" >> $GITHUB_OUTPUT

          multi=0
          if (( n > 1 )); then multi=1; fi
          echo "multi=$multi" >> $GITHUB_OUTPUT

  ssh_job:
    needs: setup
    runs-on: ${{ inputs.os_choice }} # ব্যবহারকারীর পছন্দ অনুযায়ী OS চলবে
    strategy:
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
      max-parallel: 10
    timeout-minutes: 370

    steps:
      - name: Decide hostname + runtime
        run: |
          if [[ "${{ inputs.instance_count }}" -gt 1 ]]; then
            hn="bullet${{ matrix.id }}"
          else
            hn="bullet"
          fi
          echo "TS_HOSTNAME=$hn" >> $GITHUB_ENV

          runtime=${{ inputs.runtime_minutes }}
          if [[ "${{ inputs.quick_test }}" == "true" ]]; then
            runtime=5
          elif [[ "${{ inputs.quick_test }}" != "true" && "$runtime" -lt 6 ]]; then
            runtime=355
          elif [[ "$runtime" -gt 360 ]]; then
            runtime=355
          fi
          echo "RUNTIME_MINUTES=$runtime" >> $GITHUB_ENV
          echo "Hostname: $hn  | Runtime: $runtime minutes | OS: ${{ inputs.os_choice }}"

      - name: Purge bullet* devices (single-instance only)
        if: ${{ needs.setup.outputs.multi == '0' && inputs.do_purge == 'true' }}
        run: |
          echo "Purging old 'bullet*' devices..."
          TN_ESCAPED=$(jq -nr --arg tn "${{ inputs.ts_tailnet }}" '$tn|@uri')
          DEVICES_URL="https://api.tailscale.com/api/v2/tailnet/$TN_ESCAPED/devices"
          device_list=$(curl -sf -u "${{ inputs.ts_api_key }}:" "$DEVICES_URL")
          
          if [ $? -ne 0 ]; then
            echo "::error::Failed to fetch device list from Tailscale API. Check your API key and tailnet."
            exit 1
          fi

          device_ids=$(echo "$device_list" | jq -r '.devices[]? | select(.hostname? | test("^bullet[0-9]*$")) | .id')

          if [[ -z "$device_ids" ]]; then
            echo "No 'bullet*' devices found to purge."
          else
            for id in $device_ids; do
              echo "Deleting device with ID: $id"
              curl -sf -X DELETE -u "${{ inputs.ts_api_key }}:" "https://api.tailscale.com/api/v2/device/$id"
            done
            echo "Purge complete."
          fi

      - name: Install and start Tailscale (Linux/macOS)
        if: runner.os == 'Linux' || runner.os == 'macOS'
        run: |
          curl -fsSL https://tailscale.com/install.sh | sh
          sudo tailscale up \
            --authkey "${{ inputs.ts_authkey }}" \
            --hostname "$TS_HOSTNAME" \
            --accept-dns=true \
            --accept-routes=true
          ip4=$(tailscale ip -4)
          echo "TAILSCALE_IP=$ip4" >> $GITHUB_ENV
          echo "Tailscale is up. IPv4: $ip4"

      - name: Install and start Tailscale (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Invoke-WebRequest -Uri "https://pkgs.tailscale.com/stable/tailscale-setup-latest.exe" -OutFile "tailscale-setup.exe"
          ./tailscale-setup.exe /quiet
          & "C:\Program Files\Tailscale\tailscale.exe" up --authkey="${{ inputs.ts_authkey }}" --hostname="$env:TS_HOSTNAME" --accept-dns=$true --accept-routes=$true
          $ip4 = & "C:\Program Files\Tailscale\tailscale.exe" ip -4
          echo "TAILSCALE_IP=$ip4" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          Write-Host "Tailscale is up. IPv4: $ip4"

      - name: Setup SSH Server and User (Linux)
        if: runner.os == 'Linux'
        run: |
          USER="${{ inputs.ssh_user }}"
          PASS="${{ inputs.ssh_password }}"
          sudo apt-get update
          sudo apt-get install -y openssh-server
          sudo useradd -m -s /bin/bash "$USER"
          echo "$USER:$PASS" | sudo chpasswd
          sudo usermod -aG sudo "$USER"
          sudo sed -i 's/^#*PasswordAuthentication .*/PasswordAuthentication yes/' /etc/ssh/sshd_config
          sudo service ssh restart
          echo "✅ SSH is ready on Linux!"
          echo "Connect with: ssh $USER@$TS_HOSTNAME (IP: $TAILSCALE_IP)"
          echo "Password: $PASS"

      - name: Setup SSH Server and User (macOS)
        if: runner.os == 'macOS'
        run: |
          USER="${{ inputs.ssh_user }}"
          PASS="${{ inputs.ssh_password }}"
          sudo sysadminctl -addUser "$USER" -fullName "$USER" -password "$PASS" -admin
          sudo systemsetup -setremotelogin on
          echo "✅ SSH is ready on macOS!"
          echo "Connect with: ssh $USER@$TS_HOSTNAME (IP: $TAILSCALE_IP)"
          echo "Password: $PASS"
          
      - name: Setup SSH Server and User (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $USER = "${{ inputs.ssh_user }}"
          $PASS_STRING = "${{ inputs.ssh_password }}"
          $PASS = ConvertTo-SecureString -String $PASS_STRING -AsPlainText -Force
          Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0
          Start-Service sshd
          Set-Service -Name sshd -StartupType 'Automatic'
          New-NetFirewallRule -Name sshd -DisplayName 'OpenSSH Server (sshd)' -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22
          New-LocalUser -Name "$USER" -Password $PASS -FullName "$USER" -PasswordNeverExpires
          Add-LocalGroupMember -Group "Administrators" -Member "$USER"
          $sshdConfigFile = "C:\ProgramData\ssh\sshd_config"
          (Get-Content $sshdConfigFile).replace('#PasswordAuthentication yes', 'PasswordAuthentication yes') | Set-Content $sshdConfigFile
          Restart-Service sshd
          echo "✅ SSH is ready on Windows!"
          echo "Connect with: ssh $USER@$env:TS_HOSTNAME (IP: $env:TAILSCALE_IP)"
          echo "Password: $PASS_STRING"

      - name: Keep alive
        run: |
          end_time=$(( $(date +%s) + ${{ env.RUNTIME_MINUTES }} * 60 ))
          while [ $(date +%s) -lt $end_time ]; do
            current_time=$(date +"%H:%M:%S")
            end_time_str=$(date -d "@$end_time" +"%H:%M:%S")
            echo "[SSH] Heartbeat at $current_time. Session ends at $end_time_str."
            echo "Connect: ssh ${{ inputs.ssh_user }}@$TS_HOSTNAME (IP: $TAILSCALE_IP)"
            sleep 60
          done

      - name: Dispatch next or stop
        if: always()
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          cycles=${{ inputs.cycles }}
          if (( cycles > 0 )); then
            next_cycles=$(( cycles - 1 ))
            NEXT_INPUTS_JSON=$(echo '${{ toJSON(inputs) }}' | jq --arg next_c "$next_cycles" '.cycles = $next_c')
            if (( next_cycles <= 0 )); then
              echo "Dispatching STOP workflow."
              URL="https://api.github.com/repos/${{ github.repository }}/actions/workflows/rdp-tailscale-stop.yml/dispatches"
              PAYLOAD=$(jq -n --arg tn "${{ inputs.ts_tailnet }}" \
                                --arg api_key "${{ inputs.ts_api_key }}" \
                                '{ "ts_tailnet": $tn, "ts_api_key": $api_key, "base_prefix": "bullet", "max_count": "10", "dry_run": "false" }')
            else
              echo "Dispatching next workflow with cycles=$next_cycles"
              URL="https://api.github.com/repos/${{ github.repository }}/actions/workflows/${{ github.workflow_ref_name }}"
              PAYLOAD=$NEXT_INPUTS_JSON
            fi
            BODY=$(jq -n --arg ref "${{ github.ref_name }}" --argjson inputs "$PAYLOAD" '{ "ref": $ref, "inputs": $inputs }')
            curl -s -X POST \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Authorization: Bearer $GH_TOKEN" \
              "$URL" \
              -d "$BODY"
          else
            echo "No cycles configured. This is the final run."
          fi
